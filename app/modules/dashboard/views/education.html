<!--
@invinciblerm
August 2018
-->

        <!-- Content Header (Page header) -->
        <section class="content-header">
            <h1>
              GSOC BLOG
            </h1>
            <ol class="breadcrumb">
              <li><a href="#"><i class="fa fa-dashboard"></i> Home</a></li>
              <li class="active">Blog</li>
            </ol>
          </section>
  
          <!-- Main content -->
          <section class="content">
            <!-- row -->
            <div class="row">
              <div class="col-md-12">
                <!-- The time line -->
                  <ul class="timeline">
                      <li class="time-label">
                          <span class="bg-teal-gradient">
                              Phase 0
                          </span>
                      </li>
                      <li>
                          <i class="fa fa-graduation-cap bg-blue-gradient text-white"></i>
                          <div class="timeline-item">
                              <h3 class="timeline-header"> Getting Started with SageMath </h3>
                          </div>
                      </li>
                      <li>
                          <div class="timeline-item">
                              <div class="callout callout-info col-md-10 col-sm-8 col-xs-12">
                                  <h4>In the initial weeks to get hands on experience on SageMath Development, I started working on the following tickets as described below.</h4>
    

                                  In<a href="https://trac.sagemath.org/ticket/24101"><b> #24101</b></a> I helped in implementing the Katz Centrality and Katz Matrix methods in the graph module to measure relative influence of a node in a graph network.
                                  <br>
                                  <br>
                                  In<a href="https://trac.sagemath.org/ticket/24094"> <b> #24094</b></a> I helped in implementing the methods such as Effective Resistance, Resistance Matrix and Least Resistance Pairs. These methods help to find the effective resistance between a pair of nodes in a graph network by treating all edges as resistance of 1 ohm.
                                  <br>
                                  <br>
                                  In<a href="https://trac.sagemath.org/ticket/9707"> <b> #9707</b></a> I added a signless option to Laplacian Matrix which is popular now a days to measure signless laplacian.
                                  <br>
                                  <br>
                                  In<a href="https://trac.sagemath.org/ticket/27464"> <b> #27464</b></a> I created this ticket to fix a bug and also use the cython priority_queue instead of python heap to make bidirectional_dijkstra method faster and bug free.
                                  <br>
                                  <br>
                                  In<a href="https://trac.sagemath.org/ticket/27491"> <b> #27491</b></a> I created this ticket to deprecate the parameter copy in networkx_graph method and also to remove some deprecated pieces of code.
                                  <br>
                                  <br>
                                    In<a href="https://trac.sagemath.org/ticket/27507"><b> #27507</b></a> I created this ticket to fix some documentation errors in generic_graph.py module.
                                  <br>
                                  <br>
                                    In<a href="https://trac.sagemath.org/ticket/24089"><b> #24089</b></a> I helped in implementing the methods such as max_common_neighbors and common_neighbors_matrix to find the number of common neighbors between 2 given nodes and find which nodes have the most common neighbors.
                                  <br>
                                  <br>
                                    In<a href="https://trac.sagemath.org/ticket/27496"><b> #27496</b></a> I proposed and implemented the addition of parameter weight_function for constructing networkx graphs from sage graphs.
                                  <br>
                                  <br>
                                    In<a href="https://trac.sagemath.org/ticket/27501"><b> #27501</b></a> I created this ticket to add parameters in all_paths method to make use of the multiedges present and return edges with or without labels. Parameters added were
                                    <br>
                                    <br>
                                    • use_multiedges – to take multiedges into account for enumerating the paths between source and the destination vertices.
                                    <br>
                                    • report_edges – to use edges for enumerating the paths instead of vertices as used before.
                                    <br>
                                    • label – to use labels while reporting the edges.
                                    <br>
                                    <br>
                                    In<a href="https://trac.sagemath.org/ticket/27504"><b> #27504</b> </a> Similar to #27501 I added the option to make use of multiedges and report edges instead of vertices for paths in all_simple_paths method of digraph module.
                                    <br>
                                    <br>
                                    In<a href="https://trac.sagemath.org/ticket/27557"><b> #27557</b> </a> I created this ticket to add labels option to the spanning_trees method to include labels while reporting edges in the corresponding spanning trees.
                                    <br>
                                   <br>
                                    In<a href="https://trac.sagemath.org/ticket/27502"><b> #27502</b> </a> I created this ticket to report errors while using pagerank algorithm of Igraph package.
                                    <br>
                                    <br>
                                    In<a href="https://trac.sagemath.org/ticket/27480"><b> #27480</b> </a> I created this ticket to implement the pagerank function for the sage module and make use of underlying networkx, numpy and scipy and igraph pagerank functionality.
                                    <br>
                                    <br>
                                    In<a href="https://trac.sagemath.org/ticket/27538"><b> #27538 </b> </a> I created this ticket to report the defect in cycle_basis method which gives wrong results in case of multiedges.
                                    <br>
                                    <br>
                                    In<a href="https://trac.sagemath.org/ticket/27570"><b> #27570</b> </a> I created this ticket to implement a method for finding a minimal weight cycle basis in an undirected weighted graph which has applications in signals and circuit theory.
                                    <br>
                                    <br>
                                    In<a href="https://trac.sagemath.org/ticket/27600"><b> #27600</b> </a> I created this ticket to add parameters by_weight in min_spanning_tree method and fix some errors in the method which was present.
                                    <br>
                                    <br>
       
                              
                              </div>
                              
                          </div>
                      </li>
  
                      <li class="time-label">
                          <span class="bg-green-gradient">
                              Phase 1
                          </span>
                      </li>
                      <li>
                          <i class="fa fa-pencil bg-green-gradient text-white"></i>
                          <div class="timeline-item">
                              <h3 class="timeline-header"> 12<sup>th</sup> </h3>
                          </div>
                      </li>
                      <li>
                          <div class="timeline-item">
                              <div class="callout callout-success col-md-10 col-sm-8 col-xs-12">
                                  <h4>Yen’s algorithm[1] computes source to destination k-shortest simple paths 
                                      for a graph with non-negative edge cost. It can be broken down into 2 parts,
                                      first part determining the first k-shortest path and the other part 
                                      determining all other k shortest paths. It employs any shortest path
                                      algorithm (for eg. Dijkstra’s algorithm) to find the best path and then
                                      proceeds to find k - 1 deviations of the best path. Detailed algorithm
                                      and details of the same can be found on Wikipedia/Yen’s_algorithm . The
                                      Time Complexity of Yen’s algorithm is dependent on the shortest path 
                                      algorithm used in the computation of the spur paths. If Dijkstra’s
                                      algorithm is used which has a worst case time complexity of O(N^2),
                                      the time complexity of Yen’s algorithm becomes O(kN3). Here N is the
                                      number of vertices in the graph.</h4>
                                  <p class="text-bold">


                                        function YenKSP(Graph, source, sink, K):<br>
                                    
                                        // Determine the shortest path from the source to the sink.<br>
                                        A[0] = Dijkstra(Graph, source, sink);<br>
                                        // Initialize the set to store the potential kth shortest path.<br>
                                        B = [];<br>
                                        <br>
                                        for k from 1 to K:<br>
                                            // The spur node ranges from the first node to the next to last node in the previous k-shortest path.<br>
                                            for i from 0 to size(A[k − 1]) − 2:<br>
                                            <br>
                                                // Spur node is retrieved from the previous k-shortest path, k − 1.<br>
                                                spurNode = A[k-1].node(i);<br>
                                                // The sequence of nodes from the source to the spur node of the previous k-shortest path.<br>
                                                rootPath = A[k-1].nodes(0, i);<br>
                                                <br>
                                                for each path p in A:<br>
                                                    if rootPath == p.nodes(0, i):<br>
                                                        // Remove the links that are part of the previous shortest paths which share the same root path.<br>
                                                        remove p.edge(i,i + 1) from Graph;<br>
                                                        <br>
                                                for each node rootPathNode in rootPath except spurNode:<br>
                                                    remove rootPathNode from Graph;<br>
                                                    <br>
                                                // Calculate the spur path from the spur node to the sink.<br>
                                                spurPath = Dijkstra(Graph, spurNode, sink);<br>
                                                <br>
                                                // Entire path is made up of the root path and spur path.<br>
                                                totalPath = rootPath + spurPath;<br>
                                                // Add the potential k-shortest path to the heap.<br>
                                                B.append(totalPath);<br>
                                                <br>
                                                // Add back the edges and nodes that were removed from the graph.<br>
                                                restore edges to Graph;<br>
                                                restore nodes in rootPath to Graph;<br>
                                                <br>
                                            if B is empty:<br>
                                                // This handles the case of there being no spur paths, or no spur paths left.<br>
                                                // This could happen if the spur paths have already been exhausted (added to A), <br>
                                                // or there are no spur paths at all - such as when both the source and sink vertices<br> 
                                                // lie along a "dead end".<br>
                                                break;<br>
                                            // Sort the potential k-shortest paths by cost.<br>
                                            B.sort();<br>
                                            // Add the lowest cost path becomes the k-shortest path.<br>
                                            A[k] = B[0];<br>
                                            B.pop();<br>
                                            <br>
                                        return A;<br>
                                        <br>
                                  </p>
                                  <div class="timeline-footer">
                                      <a class="btn btn-primary btn-xs" data-ng-click="vm.hscMarks=!vm.hscMarks" data-ng-if="!vm.hscMarks">Show Marks</a>
                                      <a class="btn btn-danger btn-xs" data-ng-click="vm.hscMarks=!vm.hscMarks" data-ng-if="vm.hscMarks">Hide Marks</a>
                                  </div>
                              </div>
                             
                          </div>
                      </li>
                    
                      <li class="time-label">
                          <span class="bg-red-gradient">
                              Phase 2
                          </span>
                      </li>
                      <li>
                          <i class="fa fa-pencil bg-red-gradient text-white"></i>
                          <div class="timeline-item">
                              <h3 class="timeline-header">10<sup>th</sup> </h3>
                          </div>
                      </li>
                      <li>
                          <div class="timeline-item">
                              <div class="callout callout-danger col-md-10 col-sm-8 col-xs-12">
                                  <h4>...........</h4>
                                  <p class="text-bold">........</p>
                                  <div class="timeline-footer">
                                      <a class="btn btn-primary btn-xs" data-ng-click="vm.sslcMarks=!vm.sslcMarks" data-ng-if="!vm.sslcMarks">Show Marks</a>
                                      <a class="btn btn-danger btn-xs" data-ng-click="vm.sslcMarks=!vm.sslcMarks" data-ng-if="vm.sslcMarks">Hide Marks</a>
                                  </div>
                              </div>
                              
                          </div>
                      </li>
                   
                      <li>
                          <i class="fa fa-clock-o bg-gray"></i>
                      </li>
    </ul>
              </div><!-- /.col -->
            </div>
  
          </section><!-- /.content -->
        