<!--
@invinciblerm
August 2018
-->

        <!-- Content Header (Page header) -->
        <section class="content-header">
   
            <ol class="breadcrumb">
              <li><a href="#"><i class="fa fa-dashboard"></i> Home</a></li>
              <li class="active">Blog</li>
            </ol>
          </section>
  
          <!-- Main content -->
          <section class="content">
            <!-- row -->
            <div class="row">
              <div class="col-md-12">
                <!-- The time line -->
                  <ul class="timeline">
                      <li class="time-label">
                          <span class="bg-teal-gradient">
                                <h1>Google Summer of Code 2019 Under SageMath </h1>
                          </span>
                      </li>
                      <li>
                          <i class="fa fa-graduation-cap bg-blue-gradient text-white"></i>
                          <div class="timeline-item">
                            <h2 class="timeline-header"> <h1>OVERVIEW</h1> 
                                <br>
                                My journey of GSOC with SageMath has been a fun-filled and very productive as I spent my 
                                summer in implementing and improving various algorithms in the graph module of SageMath
                                under the guidance of Dr. David Coudert as my mentor under Google Summer of Code 2019 
                                program.
                                <br>
                                The project spanning over a peroid of around 3 months, consisted in improving and 
                                implementation of new algorithms for enumeration of k shortest paths between a 
                                source and a destination vertex. As a first step certain methods were improved
                                and cleaned which served as dependencies for implementing new algorithms for k shortest
                                paths. Then at first Yen's algorithm for k shortest simple paths in a graph was implemented
                                followed by improvements such as Lawler's modification.
                                Feng's algorithm which finds k shortest paths in a directed graph efficiently was
                                implemented as a second step. After implementing both of these methods they were tested
                                for corner cases and other bugs. Then a separate module path_enumeration.pyx was made in
                                the graph module of SageMath. All the methods related to shortest paths between source and 
                                destination vertices were moved in this module. Then the last step was Cythonizing the
                                methods present in this module for speed improvements.
                            
                            </h2>
                          </div>
                      </li>
                      <li class="time-label">
                            <span class="bg-teal-gradient">
                                  Getting started
                            </span>
                        </li>
                      <li>
                          <div class="timeline-item">
                              <div class="callout callout-info col-md-10 col-sm-8 col-xs-12">
                                  <h4>In the initial weeks to get hands on experience on SageMath Development, I started reading about how things work in SageMath using the developer's guide. 
                                      As I went deeper I started to work on the following tickets as described below.
                                  </h4>
    

                                  In<a href="https://trac.sagemath.org/ticket/24101"><b> #24101</b></a> I helped in implementing the Katz Centrality and Katz Matrix methods in the graph module to measure relative influence of a node in a graph network.
                                  <br>
                                  <br>
                                  In<a href="https://trac.sagemath.org/ticket/24094"> <b> #24094</b></a> I helped in implementing the methods such as Effective Resistance, Resistance Matrix and Least Resistance Pairs. These methods help to find the effective resistance between a pair of nodes in a graph network by treating all edges as resistance of 1 ohm.
                                  <br>
                                  <br>
                                  In<a href="https://trac.sagemath.org/ticket/9707"> <b> #9707</b></a> I added a signless option to Laplacian Matrix which is popular now a days to measure signless laplacian.
                                  <br>
                                  <br>
                                  In<a href="https://trac.sagemath.org/ticket/27464"> <b> #27464</b></a> I created this ticket to fix a bug and also use the cython priority_queue instead of python heap to make bidirectional_dijkstra method faster and bug free.
                                  <br>
                                  <br>
                                  In<a href="https://trac.sagemath.org/ticket/27491"> <b> #27491</b></a> I created this ticket to deprecate the parameter copy in networkx_graph method and also to remove some deprecated pieces of code.
                                  <br>
                                  <br>
                                    In<a href="https://trac.sagemath.org/ticket/27507"><b> #27507</b></a> I created this ticket to fix some documentation errors in generic_graph.py module.
                                  <br>
                                  <br>
                                    In<a href="https://trac.sagemath.org/ticket/24089"><b> #24089</b></a> I helped in implementing the methods such as max_common_neighbors and common_neighbors_matrix to find the number of common neighbors between 2 given nodes and find which nodes have the most common neighbors.
                                  <br>
                                  <br>
                                    In<a href="https://trac.sagemath.org/ticket/27496"><b> #27496</b></a> I proposed and implemented the addition of parameter weight_function for constructing networkx graphs from sage graphs.
                                  <br>
                                  <br>
                                    In<a href="https://trac.sagemath.org/ticket/27501"><b> #27501</b></a> I created this ticket to add parameters in all_paths method to make use of the multiedges present and return edges with or without labels. Parameters added were
                                    <br>
                                    <br>
                                    • use_multiedges – to take multiedges into account for enumerating the paths between source and the destination vertices.
                                    <br>
                                    • report_edges – to use edges for enumerating the paths instead of vertices as used before.
                                    <br>
                                    • label – to use labels while reporting the edges.
                                    <br>
                                    <br>
                                    In<a href="https://trac.sagemath.org/ticket/27504"><b> #27504</b> </a> Similar to #27501 I added the option to make use of multiedges and report edges instead of vertices for paths in all_simple_paths method of digraph module.
                                    <br>
                                    <br>
                                    In<a href="https://trac.sagemath.org/ticket/27557"><b> #27557</b> </a> I created this ticket to add labels option to the spanning_trees method to include labels while reporting edges in the corresponding spanning trees.
                                    <br>
                                   <br>
                                    In<a href="https://trac.sagemath.org/ticket/27502"><b> #27502</b> </a> I created this ticket to report errors while using pagerank algorithm of Igraph package.
                                    <br>
                                    <br>
                                    In<a href="https://trac.sagemath.org/ticket/27480"><b> #27480</b> </a> I created this ticket to implement the pagerank function for the sage module and make use of underlying networkx, numpy and scipy and igraph pagerank functionality.
                                    <br>
                                    <br>
                                    In<a href="https://trac.sagemath.org/ticket/27538"><b> #27538 </b> </a> I created this ticket to report the defect in cycle_basis method which gives wrong results in case of multiedges.
                                    <br>
                                    <br>
                                    In<a href="https://trac.sagemath.org/ticket/27570"><b> #27570</b> </a> I created this ticket to implement a method for finding a minimal weight cycle basis in an undirected weighted graph which has applications in signals and circuit theory.
                                    <br>
                                    <br>
                                    In<a href="https://trac.sagemath.org/ticket/27600"><b> #27600</b> </a> I created this ticket to add parameters by_weight in min_spanning_tree method and fix some errors in the method which was present.
                                    <br>
                                    <br>
       
                              
                              </div>
                              
                          </div>
                      </li>
  
                      <li class="time-label">
                          <span class="bg-green-gradient">
                              Phase 1
                          </span>
                      </li>
                      <li>
                          <i class="fa fa-pencil bg-green-gradient text-white"></i>
                          <div class="timeline-item">
                              <h3 class="timeline-header">Implementing the Yen's algorithm for finding k shortest simple paths between a source and destination node in a graph. </h3>
                          </div>
                      </li>
                      <li>
                          <div class="timeline-item">
                              <div class="callout callout-success col-md-10 col-sm-8 col-xs-12">
                                  <h4>Yen’s algorithm[1] computes source to destination k-shortest simple paths 
                                      for a graph with non-negative edge cost. It can be broken down into 2 parts,
                                      first part determining the first k-shortest path and the second part 
                                      determining all other k shortest paths. It employs any shortest path
                                      algorithm (for eg. Dijkstra’s algorithm) to find the best path and then
                                      proceeds to find k - 1 deviations of the best path. The
                                      Time Complexity of Yen’s algorithm is dependent on the shortest path 
                                      algorithm used in the computation of the spur paths. If Dijkstra’s
                                      algorithm is used which has a worst case time complexity of O(N^<sup>2</sup>),
                                      the time complexity of Yen’s algorithm becomes O(kN<sup>3</sup>). Here N is the
                                      number of vertices in the graph.</h4>
                                  <p class="text-bold">


                                        <b>function</b> YenKSP(Graph, source, sink, K):<br>
                                    
                                        &emsp;// Determine the shortest path from the source to the sink.<br>
                                        &emsp;A[0] = Dijkstra(Graph, source, sink);<br>
                                        &emsp;// Initialize the set to store the potential kth shortest path.<br>
                                        &emsp;B = [];<br>
                                        <br>
                                        &emsp;for k from 1 to K:<br>
                                        &emsp;&emsp;// The spur node ranges from the first node to the next to last node in the previous k-shortest path.<br>
                                        &emsp;&emsp;for i from 0 to size(A[k − 1]) − 2:<br>
                                            <br>
                                            &emsp;&emsp;&emsp; // Spur node is retrieved from the previous k-shortest path, k − 1.<br>
                                            &emsp;&emsp;&emsp;   spurNode = A[k-1].node(i);<br>
                                            &emsp;&emsp;&emsp;    // The sequence of nodes from the source to the spur node of the previous k-shortest path.<br>
                                            &emsp;&emsp;&emsp;    rootPath = A[k-1].nodes(0, i);<br>
                                                <br>
                                                &emsp;&emsp;&emsp;    for each path p in A:<br>
                                                &emsp;&emsp;&emsp;&emsp;    if rootPath == p.nodes(0, i):<br>
                                                &emsp;&emsp;&emsp;&emsp;&emsp;        // Remove the links that are part of the previous shortest paths which share the same root path.<br>
                                                &emsp;&emsp;&emsp;&emsp;&emsp;        remove p.edge(i, i + 1) from Graph;<br>
                                                        <br>
                                                &emsp;&emsp;&emsp;for each node rootPathNode in rootPath except spurNode:<br>
                                                &emsp;&emsp;&emsp;&emsp;   remove rootPathNode from Graph;<br>
                                                    <br>
                                                    &emsp;&emsp;&emsp;// Calculate the spur path from the spur node to the sink.<br>
                                                    &emsp;&emsp;&emsp;spurPath = Dijkstra(Graph, spurNode, sink);<br>
                                                <br>
                                                &emsp;&emsp;&emsp;// Entire path is made up of the root path and spur path.<br>
                                                &emsp;&emsp;&emsp;totalPath = rootPath + spurPath;<br>
                                                &emsp;&emsp;&emsp;// Add the potential k-shortest path to the heap.<br>
                                                &emsp;&emsp;&emsp;B.append(totalPath);<br>
                                                <br>
                                                &emsp;&emsp;&emsp;// Add back the edges and nodes that were removed from the graph.<br>
                                                &emsp;&emsp;&emsp;restore edges to Graph;<br>
                                                &emsp;&emsp;&emsp;restore nodes in rootPath to Graph;<br>
                                                <br>
                                                &emsp;&emsp;if B is empty:<br>
                                                &emsp;&emsp;&emsp;// This handles the case of there being no spur paths, or no spur paths left.<br>
                                                &emsp;&emsp;&emsp;// This could happen if the spur paths have already been exhausted (added to A), <br>
                                                &emsp;&emsp;&emsp;// or there are no spur paths at all - such as when both the source and sink vertices<br> 
                                                &emsp;&emsp;&emsp;// lie along a "dead end".<br>
                                                &emsp;&emsp;&emsp;break;<br>
                                                &emsp;&emsp;// Sort the potential k-shortest paths by cost.<br>
                                                &emsp;&emsp;B.sort();<br>
                                                &emsp;&emsp;// Add the lowest cost path becomes the k-shortest path.<br>
                                                &emsp;&emsp;A[k] = B[0];<br>
                                                &emsp;&emsp;B.pop();<br>
                                            <br>
                                            &emsp;return A;<br>
                                        <br>
                                  </p>
                                 
                              </div>
                             
                          </div>
                      </li>
                    
                      <li class="time-label">
                          <span class="bg-red-gradient">
                              Phase 2
                          </span>
                      </li>
                      <li>
                          <i class="fa fa-pencil bg-red-gradient text-white"></i>
                          <div class="timeline-item">
                              <h3 class="timeline-header">Implementation of Feng's algorithm for finding k shortest paths between a source and destination node in a directed graph. </h3>
                          </div>
                      </li>
                      <li>
                          <div class="timeline-item">
                              <div class="callout callout-danger col-md-10 col-sm-8 col-xs-12">
                                  <h4>Gang Feng[4] proposed an algorithm similar to Yen’s algorithm but using
                                       a node classification technique to reduce the average running time of 
                                       Yen’s algorithm. When generating a candidate path deviating from the 
                                       current shortest path at a certain node, each node in the graph is 
                                       assigned one of the 3 colours namely red, green and yellow. A node on
                                       the prefix is assigned a red color, a node that can reach t 
                                       (the destination node) through a shortest path without visiting a 
                                       red node is assigned a green color, and all other nodes are assigned
                                       a yellow color. When searching for the suffix of a candidate path, 
                                       all green nodes are be bypassed, and only Dijkstra’s algorithm need 
                                       to be applied to find an all-yellow-node subpath. Since on average 
                                       the number of yellow nodes is much smaller than N this algorithm has
                                       a much lower average-case running time although the worst case time
                                       complexity remains the same.</h4>
                                  <p class="text-bold">
                                        Procedure. FindCandidates(p)<br>
                                        Input:<br>
                                        &emsp;p: the shortest path removed from Q.<br>
                                        &emsp;All nodes in G are green.<br>
                                        Result:<br>
                                        &emsp;All candidate paths deviating from p are added to Q.<br>
                                        1. if (p = p1) then<br>
                                        2. &emsp;    u:= s<br>
                                        3. else<br>
                                        4. &emsp;    u := dev(p)<br>
                                        5. &emsp;Call FindEdgesToRemove(p) to find E<sup>d</sup>(p)<br>
                                        6. &emsp;Remove all edges in E<sup>d</sup>(p)<br>
                                        7. Set all nodes in sub<sub>p</sub>(s, u) to red<br>
                                        8. for each node v ∈ sub<sub>p</sub>(s, u)<br>
                                        9. &emsp;Call GetUpStreamNodes(v) to find Y<sub>v</sub><br>
                                        10. &emsp;Set all nodes in Y<sub>v</sub> to yellow<br>
                                        11. Let Y = U<sub>v</sub>Y<sub>v</sub> <br>
                                        &emsp;where v∈sub<sub>p</sub>(s,u)<br>
                                        12. Call FindExpressEdges(Y&ensp; ∪&ensp; {u})<br>
                                        13. Set t to yellow<br>
                                        14. while (TRUE) /* infinite loop */<br>
                                        15. &emsp;Remove edge (u, next<sub>p</sub>(u))<br>
                                        16. &emsp;Find a shortest u-t path r (yellow-node only)<br>
                                        17. &emsp;Add the candidate path sub<sub>p</sub>(s, u) ⟗ r to Q<br>
                                        18. &emsp;if (next<sub>p</sub>(u) = t)<br>
                                        19. &emsp;&emsp;exit the while loop<br>
                                        20. &emsp;u := next<sub>p</sub>(u)/* advance to next node */<br>
                                        21. &emsp;Set u to red<br>
                                        22. &emsp;Call GetUpStreamNodes(u) to find Yu<br>
                                        23. &emsp;Set all nodes in Y<sub>u</sub> to yellow<br>
                                        24. &emsp;for each node v ∈ Y<sub>u</sub>&ensp; ∪&ensp;{u}<br>
                                        25. &emsp;&emsp;if |X<sub>v</sub>| > 0 then<br>
                                        26. &emsp;&emsp;&emsp;recover all express edges in X<sub>v</sub><br>
                                        27. &emsp;Call FindExpressEdges(Y<sub>u</sub> ∪ {u})<br>
                                        28. Recover all express edges<br>
                                        29. Recover all removed edges<br>
                                        30. Set all yellow and red nodes back to green<br>
                                        <br>

                                  </p>
                               
                              </div>
                              
                          </div>
                      </li>
                      <li class="time-label">
                            <span class="bg-red-gradient">
                                Phase 3
                            </span>
                        </li>
                        <li>
                            <i class="fa fa-pencil bg-red-gradient text-white"></i>
                            <div class="timeline-item">
                                <h3 class="timeline-header">Cythonization of various methods present in the path_enumeration module</sup> </h3>
                            </div>
                        </li>
                        <li>
                            <div class="timeline-item">
                                <div class="bg-teal-gradient">
                                    <h4>
                                        The methods such as all_simple_paths, all_paths_iterator, _all_paths_iterator, 
                                        feng_k_shortest_simple_paths, yen_k_shortest_simple_paths were cythonized using
                                        Cython variable declaration and Cython data structures.
                                    </h4>
                                    <p class="text-bold">
                                    <h1>Usage of k shortest paths between a source and destination vertex in SageMath looks like:</h1>
                                    <br>
                                    sage: g = DiGraph([(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 10, 1), (1, 5, 2), (5, 6, 1),
                                                       (6, 7, 1), (7, 10, 1), (1, 8, 3), (8, 9, 3), (9, 10, 1)])
                                                       <br>
                                                       <br>
                                    sage: g.show()
                                    <img class="profile-user-img img-responsive" src="../../../../images/home/graph.png" alt="Graph">
                                    <br>
                                    sage: list(g.shortest_simple_paths(1, 10, by_weight = True, algorithm = "Yen", report_weight = True))
                                    [(4, [1, 2, 3, 4, 10]), (5, [1, 5, 6, 7, 10]), (7, [1, 8, 9, 10])]
                                    <br>
                                    <br>
                                    sage: list(g.shortest_simple_paths(1, 10, by_weight = True, algorithm = "Feng", report_weight = True))
                                    [(4, [1, 2, 3, 4, 10]), (5, [1, 5, 6, 7, 10]), (7, [1, 8, 9, 10])]
                                    <br>
                                    <br>
                                    sage: list(g.shortest_simple_paths(1, 10, by_weight = True, algorithm = "Yen", report_weight = True, report_edges = True))
                                    [(4, [(1, 2), (2, 3), (3, 4), (4, 10)]),
                                     (5, [(1, 5), (5, 6), (6, 7), (7, 10)]),
                                     (7, [(1, 8), (8, 9), (9, 10)])]
                                     <br>
                                     <br>
  
                                    </p>
                                    
                                </div>
                                
                            </div>
                        </li>
                     
                      <li>
                          <i class="fa fa-clock-o bg-gray"></i>
                      </li>
    </ul>
              </div><!-- /.col -->
            </div>
  
          </section><!-- /.content -->
        