<!--
@invinciblerm
August 2018
-->

        <!-- Content Header (Page header) -->
        <section class="content-header">
   
            <ol class="breadcrumb">
              <li><a href="#"><i class="fa fa-dashboard"></i> Home</a></li>
              <li class="active">Blog</li>
            </ol>
          </section>
  
          <!-- Main content -->
          <section class="content">
            <!-- row -->
            <div class="row">
              <div class="col-md-12">
                <!-- The time line -->
                  <ul class="timeline">
                      <li class="time-label">
                          <span class="bg-teal-gradient">
               
                                             
                                                 
                            <h1>Google Summer of Code 2019 Under SageMath </h1>
                                      

                 
                                </span>
                      </li>
                      <li>
                          <i class="fa fa-pencil bg-green-gradient text-white"></i>
                          <div class="timeline-item">
                            <h2 class="timeline-header"> <h1>OVERVIEW</h1> 
                                <br>
                                <h4>
                                My journey of GSOC with SageMath has been a fun-filled and very productive as I spent my 
                                summer in implementing and improving various algorithms in the graph module of SageMath
                                under the guidance of Dr. David Coudert as my mentor under Google Summer of Code 2019 
                                program.
                                <br>
                                The project spanning over a period of 3 months, consisted in improving the implementation
                                of existing algorithms and in implementing new algorithms for enumeration of k shortest simple 
                                paths between a source and a destination vertex in a graph. As a first step certain methods were improved
                                and cleaned which served as dependencies for implementing new algorithms for k shortest
                                paths. Then at first Yen's algorithm[1] for k shortest simple paths in a graph was implemented
                                followed by improvements such as Lawler's modification[6].
                                Feng's algorithm[2] which finds k shortest paths in a directed graph efficiently was
                                implemented as a second step. After implementing both of these methods they were tested
                                for corner cases and other bugs. Then a separate module path_enumeration.pyx was made in
                                the graph module of SageMath. All the methods related to shortest paths between source and 
                                destination vertices were moved in this module. Then the last step was Cythonizing the
                                methods present in this module for speed improvements.
                                 </h4>
                            </h2>
                          </div>
                      </li>
                      <li class="time-label">
                            <span class="bg-teal-gradient">
                                  Getting started
                            </span>
                        </li>
                      <li>
                          <div class="timeline-item">
                              <div class="callout callout-info col-md-10 col-sm-8 col-xs-12">
                                    <h4>In the initial weeks to get hands on experience on SageMath Development, I started reading about how things work in SageMath using the 
                                            <a href="http://doc.sagemath.org/html/en/developer/index.html"> <font color="#0000cc">developer's guide</font></a> . 
                                          As I went deeper I started to work on the following tickets as described below.
                                      </h4>
                                  <p class="text-bold">

                                  <a href="https://trac.sagemath.org/ticket/24101"><b> <font color="#0000cc">#24101</font></b></a> I finalized this ticket which was opened since two years. I helped in implementing the Katz Centrality and Katz Matrix methods in the graph module to measure relative influence of a node in a graph.
                                  <br>
                                  <br>
                                  <a href="https://trac.sagemath.org/ticket/24094"> <b><font color="#0000cc">#24094</font> </b></a> I finalized this ticket which was opened since two years. I helped in implementing the methods such as Effective Resistance, Resistance Matrix and Least Resistance Pairs. These methods help to find the effective resistance between a pair of nodes in a graph network by treating all edges as resistance of 1 ohm.
                                  <br>
                                  <br>
                                  <a href="https://trac.sagemath.org/ticket/9707"> <b> <font color="#0000cc">#9707</font></b></a> I finalized this ticket which was opened since nine years, adding a signless option to Laplacian Matrix which is popular now a days to measure signless laplacian.
                                  <br>
                                  <br>
                                  <a href="https://trac.sagemath.org/ticket/27464"> <b><font color="#0000cc"> #27464</font></b></a> I created this ticket to fix a bug and also use the cython priority_queue instead of python heap to make bidirectional_dijkstra method faster and bug free.
                                  <br>
                                  <br>
                                  <a href="https://trac.sagemath.org/ticket/27491"> <b><font color="#0000cc">#27491</font> </b></a> I created this ticket to deprecate the parameter copy in networkx_graph method and also to remove some deprecated pieces of code.
                                  <br>
                                  <br>
                                  <a href="https://trac.sagemath.org/ticket/27507"><b><font color="#0000cc">#27507</font> </b></a> I created this ticket to fix some documentation errors in generic_graph.py module.
                                  <br>
                                  <br>
                                  <a href="https://trac.sagemath.org/ticket/24089"><b> <font color="#0000cc">#24089</font></b></a>  I finalized this ticket which was opened since two years. I helped in implementing the methods such as max_common_neighbors and common_neighbors_matrix to find the number of common neighbors between 2 given nodes and find which nodes have the most common neighbors.
                                  <br>
                                  <br>
                                  <a href="https://trac.sagemath.org/ticket/27496"><b> <font color="#0000cc">#27496</font></b></a> I proposed and implemented the addition of parameter weight_function for constructing networkx graphs from sage graphs.
                                  <br>
                                  <br>
                                  <a href="https://trac.sagemath.org/ticket/27501"><b> <font color="#0000cc">#27501</font></b></a> I created this ticket to add parameters in all_paths method to make use of the multiedges present and return edges with or without labels. Parameters added were
                                    <br>
                                    <br>
                                    &emsp; • use_multiedges – to take multiedges into account for enumerating the paths between source and the destination vertices.
                                    <br>
                                    &emsp; • report_edges – to use edges for enumerating the paths instead of vertices as used before.
                                    <br>
                                    &emsp; • label – to use labels while reporting the edges.
                                    <br>
                                    <br>
                                    <a href="https://trac.sagemath.org/ticket/27504"><b><font color="#0000cc">#27504</font> </b> </a> Similar to #27501 I added the option to make use of multiedges and report edges instead of vertices for paths in all_simple_paths method of digraph module.
                                    <br>
                                    <br>
                                    <a href="https://trac.sagemath.org/ticket/27557"><b><font color="#0000cc">#27557</font> </b> </a> I created this ticket to add labels option to the spanning_trees method to include labels while reporting edges in the corresponding spanning trees.
                                    <br>
                                   <br>
                                    <a href="https://trac.sagemath.org/ticket/27502"><b> <font color="#0000cc">#27502</font></b> </a> I created this ticket to report errors while using pagerank algorithm of Igraph package.
                                    <br>
                                    <br>
                                    <a href="https://trac.sagemath.org/ticket/27480"><b> <font color="#0000cc">#27480</font></b> </a> I created this ticket to implement the pagerank function for the sage module and make use of underlying networkx, numpy and scipy and igraph pagerank functionality.
                                    <br>
                                    <br>
                                    <a href="https://trac.sagemath.org/ticket/27538"><b> <font color="#0000cc">#27538</font> </b> </a> I created this ticket to report the defect in cycle_basis method which gives wrong results in case of multiedges.
                                    <br>
                                    <br>
                                    <a href="https://trac.sagemath.org/ticket/27570"><b><font color="#0000cc">#27570</font> </b> </a> I created this ticket to implement a method for finding a minimal weight cycle basis in an undirected weighted graph which has applications in signals and circuit theory.
                                    <br>
                                    <br>
                                    <a href="https://trac.sagemath.org/ticket/27600"><b><font color="#0000cc">#27600</font> </b> </a> I created this ticket to add parameters by_weight in min_spanning_tree method and fix some errors in the method which was present.
                                    <br>
                                    <br>
                                </p>
                              
                              </div>
                              
                          </div>
                      </li>
  
                      <li class="time-label">
                          <span class="bg-green-gradient">
                              Phase 1
                          </span>
                      </li>
                      <li>
                          <i class="fa fa-pencil bg-green-gradient text-white"></i>
                          <div class="timeline-item">
                              <h3 class="timeline-header">Implementing the Yen's algorithm[1] for finding k shortest simple paths between a source and destination node in a graph.
                            <br>
                            <br>
                            Related Tickets:
                            <br>
                            <br>
                            <a href="https://trac.sagemath.org/ticket/27859"><b> <font color="#0000cc">#27859</font></b></a> Implementing the Yen's algorithm and its improved versions
                                <br>
                            </h3>
                          </div>
                      </li>
                      <li>
                          <div class="timeline-item">
                              <div class="callout callout-success col-md-10 col-sm-8 col-xs-12">
                                  <h4>Yen’s algorithm[1] computes source to destination k-shortest simple paths 
                                      for a graph with non-negative edge cost. It can be split into 2 parts,
                                      first part determining the first shortest path and the second part 
                                      determining all other k shortest paths. It employs any shortest path
                                      algorithm (for eg. Dijkstra’s algorithm) to find the best path and then
                                      proceeds to find k - 1 deviations of the best path. The
                                      Time Complexity of Yen’s algorithm is dependent on the shortest path 
                                      algorithm used in the computation of the spur paths. If Dijkstra’s
                                      algorithm is used which has a worst case time complexity of O(N^<sup>2</sup>),
                                      the time complexity of Yen’s algorithm becomes O(kN<sup>3</sup>). Here N is the
                                      number of vertices in the graph.</h4>
                                  <p class="text-bold">


                                        <b>function</b> YenKSP(Graph, source, sink, K):<br>
                                    
                                        &emsp;// Determine the shortest path from the source to the sink.<br>
                                        &emsp;A[0] = Dijkstra(Graph, source, sink);<br>
                                        &emsp;// Initialize the set to store the potential kth shortest path.<br>
                                        &emsp;B = [];<br>
                                        <br>
                                        &emsp;for k from 1 to K:<br>
                                        &emsp;&emsp;// The spur node ranges from the first node to the next to last node in the previous k-shortest path.<br>
                                        &emsp;&emsp;for i from 0 to size(A[k − 1]) − 2:<br>
                                            <br>
                                            &emsp;&emsp;&emsp; // Spur node is retrieved from the previous k-shortest path, k − 1.<br>
                                            &emsp;&emsp;&emsp;   spurNode = A[k-1].node(i);<br>
                                            &emsp;&emsp;&emsp;    // The sequence of nodes from the source to the spur node of the previous k-shortest path.<br>
                                            &emsp;&emsp;&emsp;    rootPath = A[k-1].nodes(0, i);<br>
                                                <br>
                                                &emsp;&emsp;&emsp;    for each path p in A:<br>
                                                &emsp;&emsp;&emsp;&emsp;    if rootPath == p.nodes(0, i):<br>
                                                &emsp;&emsp;&emsp;&emsp;&emsp;        // Remove the links that are part of the previous shortest paths which share the same root path.<br>
                                                &emsp;&emsp;&emsp;&emsp;&emsp;        remove p.edge(i, i + 1) from Graph;<br>
                                                        <br>
                                                &emsp;&emsp;&emsp;for each node rootPathNode in rootPath except spurNode:<br>
                                                &emsp;&emsp;&emsp;&emsp;   remove rootPathNode from Graph;<br>
                                                    <br>
                                                    &emsp;&emsp;&emsp;// Calculate the spur path from the spur node to the sink.<br>
                                                    &emsp;&emsp;&emsp;spurPath = Dijkstra(Graph, spurNode, sink);<br>
                                                <br>
                                                &emsp;&emsp;&emsp;// Entire path is made up of the root path and spur path.<br>
                                                &emsp;&emsp;&emsp;totalPath = rootPath + spurPath;<br>
                                                &emsp;&emsp;&emsp;// Add the potential k-shortest path to the heap.<br>
                                                &emsp;&emsp;&emsp;B.append(totalPath);<br>
                                                <br>
                                                &emsp;&emsp;&emsp;// Add back the edges and nodes that were removed from the graph.<br>
                                                &emsp;&emsp;&emsp;restore edges to Graph;<br>
                                                &emsp;&emsp;&emsp;restore nodes in rootPath to Graph;<br>
                                                <br>
                                                &emsp;&emsp;if B is empty:<br>
                                                &emsp;&emsp;&emsp;// This handles the case of there being no spur paths, or no spur paths left.<br>
                                                &emsp;&emsp;&emsp;// This could happen if the spur paths have already been exhausted (added to A), <br>
                                                &emsp;&emsp;&emsp;// or there are no spur paths at all - such as when both the source and sink vertices<br> 
                                                &emsp;&emsp;&emsp;// lie along a "dead end".<br>
                                                &emsp;&emsp;&emsp;break;<br>
                                                &emsp;&emsp;// Sort the potential k-shortest paths by cost.<br>
                                                &emsp;&emsp;B.sort();<br>
                                                &emsp;&emsp;// Add the lowest cost path becomes the k-shortest path.<br>
                                                &emsp;&emsp;A[k] = B[0];<br>
                                                &emsp;&emsp;B.pop();<br>
                                            <br>
                                            &emsp;return A;<br>
                                        <br>
                                  </p>
                                 
                              </div>
                             
                          </div>
                      </li>
                    
                      <li class="time-label">
                          <span class="bg-red-gradient">
                              Phase 2
                          </span>
                      </li>
                      <li>
                          <i class="fa fa-pencil bg-red-gradient text-white"></i>
                          <div class="timeline-item">
                              <h3 class="timeline-header">Implementation of Feng's algorithm[2] for finding k shortest paths between a source and destination node in a directed graph. 
                                <br>
                                <br>
                              Related Tickets:
                              <br>
                              <br>
                              <a href="https://trac.sagemath.org/ticket/28046"><b><font color="#0000cc">#28046</font> </b></a> Improving the weight_function check in _check_weight_function method
                                  <br>
                                  <br>
                              <a href="https://trac.sagemath.org/ticket/28098"><b> <font color="#0000cc">#28098</font></b></a> Shortest path fix for the case that no path exists
                                  <br>
                                  <br>
                                </h3>
                          </div>
                      </li>
                      <li>
                          <div class="timeline-item">
                              <div class="callout callout-danger col-md-10 col-sm-8 col-xs-12">
                                  <h4>Gang Feng[2] proposed an algorithm similar to Yen’s algorithm but using
                                       a node classification technique to reduce the average running time of 
                                       Yen’s algorithm. When generating a candidate path deviating from the 
                                       current shortest path at a certain node, each node in the graph is 
                                       assigned one of the 3 colours namely red, green and yellow. A node on
                                       the prefix is assigned a red color, a node that can reach t 
                                       (the destination node) through a shortest path without visiting a 
                                       red node is assigned a green color, and all other nodes are assigned
                                       a yellow color. When searching for the suffix of a candidate path, 
                                       all green nodes can be bypassed, and Dijkstra’s algorithm need 
                                       to be applied to find an all-yellow-node subpath. Since on average 
                                       the number of yellow nodes is much smaller than N this algorithm has
                                       a much lower average-case running time although the worst case time
                                       complexity remains the same.</h4>
                                  <p class="text-bold">
                                        Procedure. FindCandidates(p)<br><br>
                                        Input:<br>
                                        &emsp;p: the shortest path removed from Q.<br>
                                        &emsp;All nodes in G are green.<br><br>
                                        Result:<br>
                                        &emsp;All candidate paths deviating from p are added to Q.<br><br>
                                         if (p = p1) then<br>
                                         &emsp;    u:= s<br>
                                         else<br>
                                         &emsp;    u := dev(p)<br>
                                         &emsp;Call FindEdgesToRemove(p) to find E<sup>d</sup>(p)<br>
                                         &emsp;Remove all edges in E<sup>d</sup>(p)<br><br>
                                         Set all nodes in sub<sub>p</sub>(s, u) to red<br>
                                         for each node v ∈ sub<sub>p</sub>(s, u)<br>
                                         &emsp;Call GetUpStreamNodes(v) to find Y<sub>v</sub><br>
                                         &emsp;Set all nodes in Y<sub>v</sub> to yellow<br><br>
                                         Let Y = U<sub>v</sub>Y<sub>v</sub> <br>
                                        &emsp;where v∈sub<sub>p</sub>(s,u)<br><br>
                                         Call FindExpressEdges(Y&ensp; ∪&ensp; {u})<br>
                                         Set t to yellow<br><br>
                                         while (TRUE) /* infinite loop */<br>
                                         &emsp;Remove edge (u, next<sub>p</sub>(u))<br>
                                         &emsp;Find a shortest u-t path r (yellow-node only)<br>
                                         &emsp;Add the candidate path sub<sub>p</sub>(s, u) ⟗ r to Q<br><br>
                                         &emsp;if (next<sub>p</sub>(u) = t)<br>
                                        &emsp;&emsp;exit the while loop<br><br>
                                         &emsp;u := next<sub>p</sub>(u)/* advance to next node */<br>
                                         &emsp;Set u to red<br>
                                         &emsp;Call GetUpStreamNodes(u) to find Yu<br>
                                         &emsp;Set all nodes in Y<sub>u</sub> to yellow<br><br>
                                         &emsp;for each node v ∈ Y<sub>u</sub>&ensp; ∪&ensp;{u}<br>
                                         &emsp;&emsp;if |X<sub>v</sub>| > 0 then<br>
                                         &emsp;&emsp;&emsp;recover all express edges in X<sub>v</sub><br><br>
                                         &emsp;Call FindExpressEdges(Y<sub>u</sub> ∪ {u})<br><br>
                                         Recover all express edges<br>
                                         Recover all removed edges<br>
                                         Set all yellow and red nodes back to green<br>
                                        <br>

                                  </p>
                               
                              </div>
                              
                          </div>
                      </li>
                      <li class="time-label">
                            <span class="bg-red-gradient">
                                Phase 3
                            </span>
                        </li>
                        <li>
                            <i class="fa fa-pencil bg-red-gradient text-white"></i>
                            <div class="timeline-item">
                                <h3 class="timeline-header">Cythonization of various methods present in the path_enumeration module</sup> 
                                    <br>
                                    <br>
                                    <a href="https://en.wikipedia.org/wiki/Cython"><b> <font color="#0000cc">Cython</font></b></a> is a programming language that aims to be a superset of the Python programming language, designed to give C-like performance with code that is written mostly in Python with optional additional C-inspired syntax.
                                    <br>
                                    <br>
                                    * Cythonization in this blog refers to converting the Python code into Cython language using Cython variable declarations and Cython data structure.
                                    <br>
                                    <br>
                                    Related Tickets:
                                    <br>
                                    <br>
                                    <a href="https://trac.sagemath.org/ticket/28221"><b> <font color="#0000cc">#28221</font></b></a> minor improvement in bidirectional_dijkstra
                                        <br>
                                        <br>
                                    <a href="https://trac.sagemath.org/ticket/28335"><b><font color="#0000cc">#28335</font> </b></a> Cythonize Yen_k_shortest_simple_paths and feng_k_shortest_simple_paths
                                        <br>
                                        <Br>
                                    <a href="https://trac.sagemath.org/ticket/28220"><b><font color="#0000cc">#28220</font> </b></a> Cythonize all_simple_paths, all_paths_iterator and _all_paths_iterator
                                        <br>
                                        <br>
                                </h3>
                            </div>
                        </li>
                        <li>
                            <div class="timeline-item">
                                <div class="bg-teal-gradient">
                                    <h4>
                                        The methods such as all_simple_paths, all_paths_iterator, _all_paths_iterator, 
                                        feng_k_shortest_simple_paths, yen_k_shortest_simple_paths were cythonized using
                                        Cython variable declaration and Cython data structures.
                                    </h4>
                                    <p class="text-bold">
                                    <h2>Usage of k shortest paths between a source and destination vertex in SageMath looks like:</h2>
                                    <br>
                                    <p class="text-bold">
                                    sage: g = DiGraph([(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 10, 1), (1, 5, 2), (5, 6, 1),
                                                       (6, 7, 1), (7, 10, 1), (1, 8, 3), (8, 9, 3), (9, 10, 1)])
                                                       <br>
                                                       <br>
                                    sage: g.show()
                                    <br>
                                    <br>
                                    <img src="../../../../images/home/graph.png" alt="Graph">
                                    <br>
                                    <br>
                                    sage: list(g.shortest_simple_paths(1, 10, by_weight = True, algorithm = "Yen", report_weight = True))
                                    <br>
                                    [(4, [1, 2, 3, 4, 10]), (5, [1, 5, 6, 7, 10]), (7, [1, 8, 9, 10])]
                                    <br>
                                    <br>
                                    sage: list(g.shortest_simple_paths(1, 10, by_weight = True, algorithm = "Feng", report_weight = True))
                                    <br>
                                    [(4, [1, 2, 3, 4, 10]), (5, [1, 5, 6, 7, 10]), (7, [1, 8, 9, 10])]
                                    <br>
                                    <br>
                                    sage: list(g.shortest_simple_paths(1, 10, by_weight = True, algorithm = "Yen", report_weight = True, report_edges = True))
                                    <br>
                                    [(4, [(1, 2), (2, 3), (3, 4), (4, 10)]),
                                    <br>
                                    (5, [(1, 5), (5, 6), (6, 7), (7, 10)]),
                                    <br>
                                    (7, [(1, 8), (8, 9), (9, 10)])]
                                     <br>
                                     <br>
                                    </p>
  
                                    </p>
                                    
                                </div>
                                
                            </div>
                        </li>
                        <li class="time-label">
                            <span class="bg-red-gradient">
                                <h2>Acknowledgements :</h2>
                            </span>
                        </li>
                        <li>
                            <i class="fa fa-pencil bg-green-gradient text-white"></i>
                            <div class="timeline-item">
                                <h4>
                                First and foremost, I would like to thank my mentor, Dr. David Coudert for
                                 his dedicated guidance and encouragement throughout the duration of GSoC and also prior to it, when 
                                 I was learning SageMath development. I have become a lot better in writing codes in Python. Working with SageMath over the summer was a great learning experience 
                                 and has enhanced my passion for open source. My Mentor was very helpful and insightful and helped me to optimize the various algorithms. I certainly want
                                   to contribute more to open source libraries and I plan on continuing to work with SageMath.
                                    <br>
                                    <br>
                                And most importantly, I express my gratitude to the people behind Google Summer of Code. I had a very enjoyable experience working in GSoC 2019.
                                </h4>
                            </div>
                        </li>
                        <li class="time-label">
                            <span class="bg-green-gradient">
                                <h2>References :</h2>
                            </span>
                        </li>
                        <li>
                            <i class="fa fa-pencil bg-green-gradient text-white"></i>
                            <div class="timeline-item">
                                <h4>
                                1. Yen, J. Y (1971), "Finding the k-Shortest Loopless Paths in a Network", Management Science, 17
                                    (11): 712–716, doi:10.1287/mnsc.17.11.712
                                    <br>
                                    <br>
                                    2. Gang Feng Finding k shortest simple paths in directed graphs: A node classification algorithm ,
                                    2014.
                                    <br>
                                    <br>
                                    3. Takuya Akiba, Takanori Hayashi, Nozomi Nori, Yoichi Iwata and Yuichi Yoshida Efficient Top-k
                                    Shortest-Path Distance Queries on Large Networks by Pruned Landmark Labeling in Proceedings
                                    of the Twenty-Ninth AAAI Conference on Artificial Intelligence, 2015.
                                    <br>
                                    <br>
                                    4. David Eppstein, Finding the k Shortest Paths, SIAM Journal on Computing, v.28 n.2, p.652-673,
                                    April 1999.
                                    <br>
                                    <br>
                                    5. Cohen, E.; Halperin, E.; Kaplan, H.; and Zwick, U. 2002. Reachability and distance queries via
                                    2-hop labels. In SODA, 937–946.
                                    <br>
                                    <br>
                                    6. Lawler, EL (1972). "A procedure for computing the k best solutions to discrete optimization
                                     problems and its application to the shortest path problem". Management Science, Theory Series.
                                      18: 401–405. doi:10.1287/mnsc.18.7.401.
                                      </h4>
                                    <br>
                            </div>
                        </li>
                        
                          <i class="fa fa-clock-o bg-gray"></i>
                      </li>
    </ul>
              </div><!-- /.col -->
            </div>
  
          </section><!-- /.content -->
        