<!--
@invinciblerm
August 2018
-->

        <!-- Content Header (Page header) -->
        <section class="content-header">
            <h1>
              GSOC BLOG
            </h1>
            <ol class="breadcrumb">
              <li><a href="#"><i class="fa fa-dashboard"></i> Home</a></li>
              <li class="active">Blog</li>
            </ol>
          </section>
  
          <!-- Main content -->
          <section class="content">
            <!-- row -->
            <div class="row">
              <div class="col-md-12">
                <!-- The time line -->
                  <ul class="timeline">
                      <li class="time-label">
                          <span class="bg-teal-gradient">
                              Phase 0
                          </span>
                      </li>
                      <li>
                          <i class="fa fa-graduation-cap bg-blue-gradient text-white"></i>
                          <div class="timeline-item">
                              <h3 class="timeline-header"> Getting Started with SageMath </h3>
                          </div>
                      </li>
                      <li>
                          <div class="timeline-item">
                              <div class="callout callout-info col-md-10 col-sm-8 col-xs-12">
                                  <h4>In the initial weeks to get hands on experience on SageMath Development, I started working on the following tickets as described below.</h4>
    

                                  In<a href="https://trac.sagemath.org/ticket/24101"><b> #24101</b></a> I helped in implementing the Katz Centrality and Katz Matrix methods in the graph module to measure relative influence of a node in a graph network.
                                  <br>
                                  <br>
                                  In<a href="https://trac.sagemath.org/ticket/24094"> <b> #24094</b></a> I helped in implementing the methods such as Effective Resistance, Resistance Matrix and Least Resistance Pairs. These methods help to find the effective resistance between a pair of nodes in a graph network by treating all edges as resistance of 1 ohm.
                                  <br>
                                  <br>
                                  In<a href="https://trac.sagemath.org/ticket/9707"> <b> #9707</b></a> I added a signless option to Laplacian Matrix which is popular now a days to measure signless laplacian.
                                  <br>
                                  <br>
                                  In<a href="https://trac.sagemath.org/ticket/27464"> <b> #27464</b></a> I created this ticket to fix a bug and also use the cython priority_queue instead of python heap to make bidirectional_dijkstra method faster and bug free.
                                  <br>
                                  <br>
                                  In<a href="https://trac.sagemath.org/ticket/27491"> <b> #27491</b></a> I created this ticket to deprecate the parameter copy in networkx_graph method and also to remove some deprecated pieces of code.
                                  <br>
                                  <br>
                                    In<a href="https://trac.sagemath.org/ticket/27507"><b> #27507</b></a> I created this ticket to fix some documentation errors in generic_graph.py module.
                                  <br>
                                  <br>
                                    In<a href="https://trac.sagemath.org/ticket/24089"><b> #24089</b></a> I helped in implementing the methods such as max_common_neighbors and common_neighbors_matrix to find the number of common neighbors between 2 given nodes and find which nodes have the most common neighbors.
                                  <br>
                                  <br>
                                    In<a href="https://trac.sagemath.org/ticket/27496"><b> #27496</b></a> I proposed and implemented the addition of parameter weight_function for constructing networkx graphs from sage graphs.
                                  <br>
                                  <br>
                                    In<a href="https://trac.sagemath.org/ticket/27501"><b> #27501</b></a> I created this ticket to add parameters in all_paths method to make use of the multiedges present and return edges with or without labels. Parameters added were
                                    <br>
                                    <br>
                                    • use_multiedges – to take multiedges into account for enumerating the paths between source and the destination vertices.
                                    <br>
                                    • report_edges – to use edges for enumerating the paths instead of vertices as used before.
                                    <br>
                                    • label – to use labels while reporting the edges.
                                    <br>
                                    <br>
                                    In<a href="https://trac.sagemath.org/ticket/27504"><b> #27504</b> </a> Similar to #27501 I added the option to make use of multiedges and report edges instead of vertices for paths in all_simple_paths method of digraph module.
                                    <br>
                                    <br>
                                    In<a href="https://trac.sagemath.org/ticket/27557"><b> #27557</b> </a> I created this ticket to add labels option to the spanning_trees method to include labels while reporting edges in the corresponding spanning trees.
                                    <br>
                                   <br>
                                    In<a href="https://trac.sagemath.org/ticket/27502"><b> #27502</b> </a> I created this ticket to report errors while using pagerank algorithm of Igraph package.
                                    <br>
                                    <br>
                                    In<a href="https://trac.sagemath.org/ticket/27480"><b> #27480</b> </a> I created this ticket to implement the pagerank function for the sage module and make use of underlying networkx, numpy and scipy and igraph pagerank functionality.
                                    <br>
                                    <br>
                                    In<a href="https://trac.sagemath.org/ticket/27538"><b> #27538 </b> </a> I created this ticket to report the defect in cycle_basis method which gives wrong results in case of multiedges.
                                    <br>
                                    <br>
                                    In<a href="https://trac.sagemath.org/ticket/27570"><b> #27570</b> </a> I created this ticket to implement a method for finding a minimal weight cycle basis in an undirected weighted graph which has applications in signals and circuit theory.
                                    <br>
                                    <br>
                                    In<a href="https://trac.sagemath.org/ticket/27600"><b> #27600</b> </a> I created this ticket to add parameters by_weight in min_spanning_tree method and fix some errors in the method which was present.
                                    <br>
                                    <br>
       
                              
                              </div>
                              
                          </div>
                      </li>
  
                      <li class="time-label">
                          <span class="bg-green-gradient">
                              Phase 1
                          </span>
                      </li>
                      <li>
                          <i class="fa fa-pencil bg-green-gradient text-white"></i>
                          <div class="timeline-item">
                              <h3 class="timeline-header"> 12<sup>th</sup> </h3>
                          </div>
                      </li>
                      <li>
                          <div class="timeline-item">
                              <div class="callout callout-success col-md-10 col-sm-8 col-xs-12">
                                  <h4>Yen’s algorithm[1] computes source to destination k-shortest simple paths 
                                      for a graph with non-negative edge cost. It can be broken down into 2 parts,
                                      first part determining the first k-shortest path and the other part 
                                      determining all other k shortest paths. It employs any shortest path
                                      algorithm (for eg. Dijkstra’s algorithm) to find the best path and then
                                      proceeds to find k - 1 deviations of the best path. Detailed algorithm
                                      and details of the same can be found on Wikipedia/Yen’s_algorithm . The
                                      Time Complexity of Yen’s algorithm is dependent on the shortest path 
                                      algorithm used in the computation of the spur paths. If Dijkstra’s
                                      algorithm is used which has a worst case time complexity of O(N^2),
                                      the time complexity of Yen’s algorithm becomes O(kN3). Here N is the
                                      number of vertices in the graph.</h4>
                                  <p class="text-bold">


                                        function YenKSP(Graph, source, sink, K):<br>
                                    
                                        // Determine the shortest path from the source to the sink.<br>
                                        A[0] = Dijkstra(Graph, source, sink);<br>
                                        // Initialize the set to store the potential kth shortest path.<br>
                                        B = [];<br>
                                        <br>
                                        for k from 1 to K:<br>
                                            // The spur node ranges from the first node to the next to last node in the previous k-shortest path.<br>
                                            for i from 0 to size(A[k − 1]) − 2:<br>
                                            <br>
                                                // Spur node is retrieved from the previous k-shortest path, k − 1.<br>
                                                spurNode = A[k-1].node(i);<br>
                                                // The sequence of nodes from the source to the spur node of the previous k-shortest path.<br>
                                                rootPath = A[k-1].nodes(0, i);<br>
                                                <br>
                                                for each path p in A:<br>
                                                    if rootPath == p.nodes(0, i):<br>
                                                        // Remove the links that are part of the previous shortest paths which share the same root path.<br>
                                                        remove p.edge(i,i + 1) from Graph;<br>
                                                        <br>
                                                for each node rootPathNode in rootPath except spurNode:<br>
                                                    remove rootPathNode from Graph;<br>
                                                    <br>
                                                // Calculate the spur path from the spur node to the sink.<br>
                                                spurPath = Dijkstra(Graph, spurNode, sink);<br>
                                                <br>
                                                // Entire path is made up of the root path and spur path.<br>
                                                totalPath = rootPath + spurPath;<br>
                                                // Add the potential k-shortest path to the heap.<br>
                                                B.append(totalPath);<br>
                                                <br>
                                                // Add back the edges and nodes that were removed from the graph.<br>
                                                restore edges to Graph;<br>
                                                restore nodes in rootPath to Graph;<br>
                                                <br>
                                            if B is empty:<br>
                                                // This handles the case of there being no spur paths, or no spur paths left.<br>
                                                // This could happen if the spur paths have already been exhausted (added to A), <br>
                                                // or there are no spur paths at all - such as when both the source and sink vertices<br> 
                                                // lie along a "dead end".<br>
                                                break;<br>
                                            // Sort the potential k-shortest paths by cost.<br>
                                            B.sort();<br>
                                            // Add the lowest cost path becomes the k-shortest path.<br>
                                            A[k] = B[0];<br>
                                            B.pop();<br>
                                            <br>
                                        return A;<br>
                                        <br>
                                  </p>
                                  <div class="timeline-footer">
                                      <a class="btn btn-primary btn-xs" data-ng-click="vm.hscMarks=!vm.hscMarks" data-ng-if="!vm.hscMarks">Show Marks</a>
                                      <a class="btn btn-danger btn-xs" data-ng-click="vm.hscMarks=!vm.hscMarks" data-ng-if="vm.hscMarks">Hide Marks</a>
                                  </div>
                              </div>
                             
                          </div>
                      </li>
                    
                      <li class="time-label">
                          <span class="bg-red-gradient">
                              Phase 2
                          </span>
                      </li>
                      <li>
                          <i class="fa fa-pencil bg-red-gradient text-white"></i>
                          <div class="timeline-item">
                              <h3 class="timeline-header">10<sup>th</sup> </h3>
                          </div>
                      </li>
                      <li>
                          <div class="timeline-item">
                              <div class="callout callout-danger col-md-10 col-sm-8 col-xs-12">
                                  <h4>Gang Feng[4] proposed an algorithm similar to Yen’s algorithm but using
                                       a node classification technique to reduce the average running time of 
                                       Yen’s algorithm. When generating a candidate path deviating from the 
                                       current shortest path at a certain node, each node in the graph is 
                                       assigned one of the 3 colours namely red, green and yellow. A node on
                                       the prefix is assigned a red color, a node that can reach t 
                                       (the destination node) through a shortest path without visiting a 
                                       red node is assigned a green color, and all other nodes are assigned
                                       a yellow color. When searching for the suffix of a candidate path, 
                                       all green nodes are be bypassed, and only Dijkstra’s algorithm need 
                                       to be applied to find an all-yellow-node subpath. Since on average 
                                       the number of yellow nodes is much smaller than N this algorithm has
                                       a much lower average-case running time although the worst case time
                                       complexity remains the same.</h4>
                                  <p class="text-bold">
                                        Procedure. FindCandidates(p)<br>
                                        Input:<br>
                                        p: the shortest path removed from Q.<br>
                                        All nodes in G are green.<br>
                                        Result:<br>
                                        All candidate paths deviating from p are added to Q.<br>
                                        1 if (p = p1) then<br>
                                        2 u:= s<br>
                                        3 else<br>
                                        4 u := dev(p)<br>
                                        5 Call FindEdgesToRemove(p) to find Ed(p)<br>
                                        6 Remove all edges in Ed(p)<br>
                                        7 Set all nodes in subp(s, u) to red<br>
                                        8 for each node v ∈ subp(s, u)<br>
                                        9 Call GetUpStreamNodes(v) to find Yv<br>
                                        10 Set all nodes in Yv to yellow<br>
                                        11 Let Y= ∪<br>
                                        v∈subp(s,u)<br>
                                        Yv<br>
                                        12 Call FindExpressEdges(Y ∪ {u})<br>
                                        13 Set t to yellow<br>
                                        14 while (TRUE) /* infinite loop */<br>
                                        15 Remove edge (u, nextp(u))<br>
                                        16 Find a shortest u-t path r (yellow-node only)<br>
                                        17 Add the candidate path subp(s, u)  r to Q<br>
                                        18 if (nextp(u) = t)<br>
                                        19 exit the while loop<br>
                                        20 u := nextp(u)/* advance to next node */<br>
                                        21 Set u to red<br>
                                        22 Call GetUpStreamNodes(u) to find Yu<br>
                                        23 Set all nodes in Yu to yellow<br>
                                        24 for each node v ∈ Yu ∪ {u}<br>
                                        25 if |Xv| > 0 then<br>
                                        26 recover all express edges in Xv<br>
                                        27 Call FindExpressEdges(Yu ∪ {u})<br>
                                        28 Recover all express edges<br>
                                        29 Recover all removed edges<br>
                                        30 Set all yellow and red nodes back to green<br>
                                        <br>

                                  </p>
                                  <div class="timeline-footer">
                                      <a class="btn btn-primary btn-xs" data-ng-click="vm.sslcMarks=!vm.sslcMarks" data-ng-if="!vm.sslcMarks">Show Marks</a>
                                      <a class="btn btn-danger btn-xs" data-ng-click="vm.sslcMarks=!vm.sslcMarks" data-ng-if="vm.sslcMarks">Hide Marks</a>
                                  </div>
                              </div>
                              
                          </div>
                      </li>
                   
                      <li>
                          <i class="fa fa-clock-o bg-gray"></i>
                      </li>
    </ul>
              </div><!-- /.col -->
            </div>
  
          </section><!-- /.content -->
        